import os
import struct
from io import BytesIO
from typing import Tuple

from PySide6.QtWidgets import QWidget
from qfluentwidgets import PushButton, InfoBar

from src.utils.helpers import BaseWidget

# GUI
try:
    from PySide6 import QtWidgets, QtCore
except ImportError:
    QtWidgets = None
    QtCore = None


FO4_FORM_VERSION = 131  # Common FO4 form version used in many records
TES4_FLAG_ESL = 0x00000002  # TES4 record flag: ESL


def fourcc(s: str) -> int:
    return int.from_bytes(s.encode('ascii'), 'little')


def pack_record_header(signature: str, data_size: int, form_id: int, form_version: int = FO4_FORM_VERSION,
                        record_flags: int = 0, vc_info1: int = 0, vc_info2: int = 0) -> bytes:
    # Bethesda record header (TES4/5/FO4):
    # char[4] signature, uint32 data_size, uint32 flags, uint32 formid,
    # uint32 vcinfo1, uint16 form_version, uint16 vcinfo2
    return (
        signature.encode('ascii') +
        struct.pack('<I', data_size) +
        struct.pack('<I', record_flags) +
        struct.pack('<I', form_id) +
        struct.pack('<I', vc_info1) +
        struct.pack('<H', form_version) +
        struct.pack('<H', vc_info2)
    )


def pack_subrecord(name: str, data: bytes) -> bytes:
    # Subrecord: char[4] name, uint16 size, data (size bytes)
    return name.encode('ascii') + struct.pack('<H', len(data)) + data


def pack_group_header(label_fourcc: int, group_type: int, group_size: int,
                      stamp: int = 0, unknown: int = 0, vc_info: int = 0) -> bytes:
    # GRUP: 'GRUP'(4), uint32 size, uint32 label, uint32 group_type,
    # uint16 stamp, uint16 unknown, uint32 vc_info
    return (
        b'GRUP' +
        struct.pack('<I', group_size) +
        struct.pack('<I', label_fourcc) +
        struct.pack('<I', group_type) +
        struct.pack('<H', stamp) +
        struct.pack('<H', unknown) +
        struct.pack('<I', vc_info)
    )


def build_tes4_header(num_records: int, next_object_id: int,
                       author: str = 'EZESP', description: str = 'Generated by EZESP',
                       masters: list | None = None,
                       record_flags: int = 0) -> bytes:
    buf = BytesIO()

    # HEDR: version (float), num records (uint32), next object id (uint32)
    hedr = struct.pack('<fII', 1.0, num_records, next_object_id)
    buf.write(pack_subrecord('HEDR', hedr))

    if author:
        buf.write(pack_subrecord('CNAM', author.encode('utf-8')))
    if description:
        buf.write(pack_subrecord('SNAM', description.encode('utf-8')))

    # Masters list: Each master is MAST (zstring, null-terminated) followed by DATA (uint64)
    if masters:
        for m in masters:
            m_z = m.encode('ascii') + b'\x00'
            buf.write(pack_subrecord('MAST', m_z))
            buf.write(pack_subrecord('DATA', struct.pack('<Q', 0)))

    data = buf.getvalue()

    # TES4 is a top-level record with FormID 0
    header = pack_record_header('TES4', len(data), form_id=0, form_version=FO4_FORM_VERSION, record_flags=record_flags)
    return header + data


def build_omod_record(editor_id: str, form_id: int) -> bytes:
    # Minimal OMOD with only EDID subrecord
    edid = pack_subrecord('EDID', editor_id.encode('ascii'))
    data = edid
    header = pack_record_header('OMOD', len(data), form_id=form_id, form_version=FO4_FORM_VERSION)
    return header + data


def build_kywd_record(editor_id: str, form_id: int, tnam: str) -> bytes:
    # KYWD with EDID and TNAM (FO4 uses TNAM for keyword text)
    edid = pack_subrecord('EDID', editor_id.encode('ascii'))
    tnam_bytes = tnam.encode('utf-8')
    tnam_sr = pack_subrecord('TNAM', tnam_bytes)
    data = edid + tnam_sr
    header = pack_record_header('KYWD', len(data), form_id=form_id, form_version=FO4_FORM_VERSION)
    return header + data


def build_misc_record(editor_id: str, form_id: int, full_name: str, model_path: str,
                       preview_trns_formid: int, value: int, keyword_formid: int) -> bytes:
    # Minimal FO4 MISC record with required fields per request
    edid = pack_subrecord('EDID', editor_id.encode('ascii'))
    full = pack_subrecord('FULL', full_name.encode('utf-8'))
    # Model path as raw string; FO4 model struct is more complex but filename alone works for simple tools
    modl = pack_subrecord('MODL', model_path.encode('ascii'))
    # Keywords: KSIZ (uint32 count) followed by KWDA with formIDs (uint32 each in subrecord)
    ksiz = pack_subrecord('KSIZ', struct.pack('<I', 1))
    kodwa = pack_subrecord('KWDA', struct.pack('<I', keyword_formid))
    # Preview transform reference
    trns = pack_subrecord('TRNS', struct.pack('<I', preview_trns_formid))
    # Value and weight: pack as int32 value and float weight (0.0)
    data_payload = struct.pack('<If', value, 0.0)
    data_sr = pack_subrecord('DATA', data_payload)
    data = edid + full + modl + ksiz + kodwa + trns + data_sr
    header = pack_record_header('MISC', len(data), form_id=form_id, form_version=FO4_FORM_VERSION)
    return header + data


def build_omod_record_with_refs(editor_id: str, form_id: int, misc_form_id: int, mod_assoc_keyword_formid: int) -> bytes:
    # OMOD with EDID, LNAM pointing to MISC, and tag the Mod Association keyword via KWDA for simplicity
    edid = pack_subrecord('EDID', editor_id.encode('ascii'))
    lnam = pack_subrecord('LNAM', struct.pack('<I', misc_form_id))
    # Not canonical properties, but include keyword to satisfy "use as a property" requirement minimally
    ksiz = pack_subrecord('KSIZ', struct.pack('<I', 1))
    kodwa = pack_subrecord('KWDA', struct.pack('<I', mod_assoc_keyword_formid))
    data = edid + lnam + ksiz + kodwa
    header = pack_record_header('OMOD', len(data), form_id=form_id, form_version=FO4_FORM_VERSION)
    return header + data


def build_cobj_record(editor_id: str, form_id: int, omod_form_id: int) -> bytes:
    # Minimal COBJ: EDID and CNAM (Created Object = the OMOD FormID)
    edid = pack_subrecord('EDID', editor_id.encode('ascii'))
    cnam = pack_subrecord('CNAM', struct.pack('<I', omod_form_id))
    data = edid + cnam
    header = pack_record_header('COBJ', len(data), form_id=form_id, form_version=FO4_FORM_VERSION)
    return header + data


def build_top_group_by_sig(sig: str, records_bytes: bytes) -> bytes:
    # group type 0 = Top-level group, label is the signature fourcc
    label = fourcc(sig)
    # group size includes the 24-byte group header itself
    group_size = 24 + len(records_bytes)
    header = pack_group_header(label_fourcc=label, group_type=0, group_size=group_size)
    return header + records_bytes


def make_plugin_bytes(plugin_basename: str, author: str = 'EZESP', description: str = 'Generated by EZESP') -> Tuple[str, bytes]:
    # sanitize base name
    base = plugin_basename.strip()
    if not base:
        raise ValueError('Plugin name must not be empty')
    if base.lower().endswith('.esp'):
        base = os.path.splitext(base)[0]

    file_name = base + '.esp'

    # Assign FormIDs suitable for ESL (light plugin) by using local IDs only (lower 24 bits)
    # Start from the common starting point 0x00000800 and allocate sequentially.
    # The game/xEdit will display these as FExx08xx at runtime based on load order; we should not hardcode FE indices.
    next_id = 0x00000800

    # Reserve IDs in sequence:
    # 0x00000800: original demo OMOD (<base>_test)
    # 0x00000801..0x00000803: three KYWDs
    # 0x00000804..: 5×(MISC, OMOD, COBJ) in that order
    omod_demo_form_id = next_id; next_id += 1
    kywd1_form_id = next_id; next_id += 1  # ma_<base> (Mod Association)
    kywd2_form_id = next_id; next_id += 1  # s_40_<base>
    kywd3_form_id = next_id; next_id += 1  # <base>_Anims

    # Build records
    records_kywd = []
    records_misc = []
    records_omod = []
    records_cobj = []

    # Keywords
    kywd1 = build_kywd_record(f'ma_{base}', kywd1_form_id, 'Mod Association')
    kywd2 = build_kywd_record(f's_40_{base}', kywd2_form_id, 'Sound')
    kywd3 = build_kywd_record(f'{base}_Anims', kywd3_form_id, 'Anim Archetype')
    records_kywd.extend([kywd1, kywd2, kywd3])

    # Demo OMOD (kept from previous requirement)
    demo_editor_id = f'{base}_test'
    demo_omod = build_omod_record(demo_editor_id, omod_demo_form_id)
    records_omod.append(demo_omod)

    # External keyword for MISC: ObjectTypeLooseMod [KYWD:00135C17]
    object_type_loose_mod_kw_formid = 0x00135C17
    # Preview transform: MiscMod01 [TRNS:00248769]
    preview_trns_formid = 0x00248769

    # Allocate form IDs for 5 sets (continue from current next_id)
    for n in range(1, 6):
        # MISC first
        misc_edid = f'{base}_barrel_{n}_misc_mod'
        misc_full = f'barrel_{n}'
        misc_value = 20 + n
        misc_form_id = next_id; next_id += 1
        misc_rec = build_misc_record(
            editor_id=misc_edid,
            form_id=misc_form_id,
            full_name=misc_full,
            model_path='Props\\ModsPartBox\\ModCrate.nif',
            preview_trns_formid=preview_trns_formid,
            value=misc_value,
            keyword_formid=object_type_loose_mod_kw_formid,
        )
        records_misc.append(misc_rec)

        # OMOD next, referencing the MISC and Mod Association keyword
        omod_edid = f'{base}_barrel_{n}_omod'
        omod_form_id = next_id; next_id += 1
        omod_rec = build_omod_record_with_refs(
            editor_id=omod_edid,
            form_id=omod_form_id,
            misc_form_id=misc_form_id,
            mod_assoc_keyword_formid=kywd1_form_id,
        )
        records_omod.append(omod_rec)

        # COBJ last, referencing the OMOD via CNAM
        cobj_edid = f'{base}_barrel_{n}_co_mod'
        cobj_form_id = next_id; next_id += 1
        cobj_rec = build_cobj_record(
            editor_id=cobj_edid,
            form_id=cobj_form_id,
            omod_form_id=omod_form_id,
        )
        records_cobj.append(cobj_rec)

    # Compute header counts
    total_records = len(records_kywd) + len(records_misc) + len(records_omod) + len(records_cobj)
    # HEDR Next Object ID stores the next local ID (lower 24 bits)
    next_object_id = next_id & 0x00FFFFFF

    # Build TES4 header with master Fallout4.esm (required due to base-game FormID references)
    tes4 = build_tes4_header(
        num_records=total_records,
        next_object_id=next_object_id,
        author=author,
        description=description,
        masters=['Fallout4.esm'],
        record_flags=TES4_FLAG_ESL
    )

    # Build GRUPs by signature and in required order: MISC -> OMOD -> COBJ; KYWD can be anywhere, keep first.
    kywd_group = build_top_group_by_sig('KYWD', b''.join(records_kywd))
    misc_group = build_top_group_by_sig('MISC', b''.join(records_misc))
    omod_group = build_top_group_by_sig('OMOD', b''.join(records_omod))
    cobj_group = build_top_group_by_sig('COBJ', b''.join(records_cobj))

    # The file is TES4 record then the GRUPs
    plugin_data = tes4 + kywd_group + misc_group + omod_group + cobj_group
    return file_name, plugin_data


def write_plugin(output_dir: str, plugin_basename: str, author: str = 'EZESP', description: str = 'Generated by EZESP') -> str:
    file_name, data = make_plugin_bytes(plugin_basename, author=author, description=description)
    os.makedirs(output_dir, exist_ok=True)
    full_path = os.path.join(output_dir, file_name)
    with open(full_path, 'wb') as f:
        f.write(data)
    return full_path


class OMODMakerWidget(BaseWidget):
    def __init__(self, parent):
        super().__init__(parent=parent, text="OMOD Creator", vertical=True)
        self.setWindowTitle('Fallout 4 ESP Creator (OMOD + Keywords)')
        self.setMinimumWidth(520)
        self.main_widget = QWidget()

        self.name_edit = QtWidgets.QLineEdit()
        self.name_edit.setPlaceholderText('Plugin name (without .esp)')

        self.author_edit = QtWidgets.QLineEdit()
        self.author_edit.setPlaceholderText('Author name (will be written to CNAM)')

        self.desc_edit = QtWidgets.QTextEdit()
        self.desc_edit.setPlaceholderText('Description (will be written to SNAM)')
        self.desc_edit.setFixedHeight(70)

        # Load defaults from config (no cwd fallback)
        default_dir = ''
        self.dir_edit = QtWidgets.QLineEdit()
        self.dir_btn = PushButton('Browse…')
        self.create_btn = PushButton('Create ESP')
        if getattr(self, 'cfg', None) is not None:
            vals = self.cfg.get_many({'out_dir': default_dir, 'author': '', 'description': ''})
            self.dir_edit.setText(vals.get('out_dir', default_dir) or '')
            if vals.get('author'):
                self.author_edit.setText(vals.get('author', ''))
            if vals.get('description'):
                self.desc_edit.setPlainText(vals.get('description', ''))
        else:
            self.dir_edit.setText('')

        form = QtWidgets.QFormLayout()
        form.addRow('Plugin name:', self.name_edit)
        form.addRow('Author:', self.author_edit)
        form.addRow('Description:', self.desc_edit)

        dir_layout = QtWidgets.QHBoxLayout()
        dir_layout.addWidget(self.dir_edit)
        dir_layout.addWidget(self.dir_btn)
        form.addRow('Output folder:', dir_layout)

        main_layout = QtWidgets.QVBoxLayout(self.main_widget)
        main_layout.addLayout(form)
        main_layout.addStretch(1)
        main_layout.addWidget(self.create_btn)

        self.addToFrame(self.main_widget)

        self.dir_btn.clicked.connect(self.choose_dir)
        self.create_btn.clicked.connect(self.create_plugin)

        self.addToFrame(self.main_widget)


    def choose_dir(self):
        d = QtWidgets.QFileDialog.getExistingDirectory(self, 'Select Output Folder', self.dir_edit.text() or '')
        if d:
            self.dir_edit.setText(d)
            if getattr(self, 'cfg', None) is not None:
                try:
                    self.cfg.set('out_dir', d)
                except Exception:
                    pass

    def create_plugin(self):
        name = self.name_edit.text().strip()
        author = self.author_edit.text().strip() or 'EZESP'
        description = self.desc_edit.toPlainText().strip() or 'Generated by EZESP'
        out_dir = self.dir_edit.text().strip()
        if not name:
            InfoBar.warning(
                title=self.tr('Validation'),
                content=self.tr('Please enter a plugin name.'),
                duration=3000,
                parent=self,
            )
            return
        if not out_dir:
            InfoBar.warning(
                title=self.tr('Validation'),
                content=self.tr('Please choose an output folder (Settings are stored in config.json).'),
                duration=3000,
                parent=self,
            )
            return
        # persist config
        if getattr(self, 'cfg', None) is not None:
            try:
                self.cfg.set_many({'out_dir': out_dir, 'author': author, 'description': description})
            except Exception:
                pass
        try:
            path = write_plugin(out_dir, name, author=author, description=description)
        except Exception as e:
            InfoBar.error(
                title=self.tr('Error'),
                content=self.tr(f'Failed to create plugin:\n{e}'),
                duration=5000,
                parent=self,
            )
            return
        base = os.path.splitext(os.path.basename(path))[0]
        # Build a summary of created barrel records
        barrel_lines = []
        for n in range(1, 6):
            barrel_lines.append(
                f'  Barrel {n}: MISC {base}_barrel_{n}_misc_mod, '
                f'OMOD {base}_barrel_{n}_omod, COBJ {base}_barrel_{n}_co_mod'
            )
        barrels_summary = "\n".join(barrel_lines)
        msg = (
            f'Created plugin:\n{path}\n\n'
            f'KYWDs created:\n'
            f'  - ma_{base} (TNAM: "Mod Association")\n'
            f'  - s_40_{base} (TNAM: "Sound")\n'
            f'  - {base}_Anims (TNAM: "Anim Archetype")\n\n'
            f'5 barrel sets created (MISC -> OMOD -> COBJ):\n{barrels_summary}\n\n'
            f'Legacy demo OMOD: {base}_test\n\n'
            f'Author (CNAM): {author}\nDescription (SNAM): {description}'
        )
        InfoBar.success(
            title=self.tr('Success'),
            content=self.tr(msg),
            duration=4000,
            parent=self,
        )

